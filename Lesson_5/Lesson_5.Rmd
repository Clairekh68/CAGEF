---
title: "Lesson 5 - Linear Regression, Multiple Linear Regression, ANOVA, ANCOVA: Choosing the Best Model for the Job"
output: 
  html_document:
          keep_md: yes
          toc: TRUE
          toc_depth: 3
  html_notebook:
          toc: TRUE
          toc_depth: 3
---
***
![] 

</br>

##A quick intro to the intro to R Lesson Series

</br>

This 'Intro to R Lesson Series' is brought to you by the Centre for the Analysis of Genome Evolution & Function's (CAGEF) bioinformatics training initiative. This course was developed based on feedback on the needs and interests of the Department of Cell & Systems Biology and the Department of Ecology and Evolutionary Biology. 


This lesson is the fifth in a 6-part series. The idea is that at the end of the series, you will be able to import and manipulate your data, make exploratory plots, perform some basic statistical tests, test a regression model, and make some even prettier plots and documents to share your results. 


![](img/data-science-explore.png)

</br>

How do we get there? Today we are going to be testing and interpreting the output of different regression models. We are also going to learn how to compare models and choose the best model that fits our data. For the last lesson, we will learn to write some functions, which really can save you time and help scale up your analyses.


![](img/spotify-howtobuildmvp.gif)

</br>

The structure of the class is a code-along style. It is hands on. The lecture AND code we are going through are available on GitHub for download at https://github.com/eacton/CAGEF __(Note: repo is private until approved)__, so you can spend the time coding and not taking notes. As we go along, there will be some challenge questions and multiple choice questions on Socrative. At the end of the class if you could please fill out a post-lesson survey (https://www.surveymonkey.com/r/PVHDKDB), it will help me further develop this course and would be greatly appreciated. 

***

####Packages Used in This Lesson

The following packages are used in this lesson:

`tidyverse` (`ggplot2`, `tidyr`, `dplyr`)     
`limma`
`gee`  
`knitr`     
`kableExtra`     

Please install and load these packages for the lesson. In this document I will load each package separately, but I will not be reminding you to install the package. Remember: these packages may be from CRAN OR Bioconductor. 


***
####Highlighting

`grey background` - a package, function, code or command      
*italics* - an important term or concept     
**bold** - heading or 'grammar of graphics' term      
<span style="color:blue">blue text</span> - named or unnamed hyperlink     

***

###Homework

_Discussion: Taking up the Lesson 4 Challenge question_


***
__Objective:__ At the end of this session you will be able to perform simple and multiple linear regression, one- and multiway analysis of variance (ANOVA) and analysis of covariance (ANCOVA). You will be able to interpret the statistics that come out of this model, be cognizant of the assumptions the model makes, and use F-tests to select the best model for the job. 


```{r message = FALSE}
library(tidyverse)
library(knitr)
library(kableExtra)
library(gee)
library(multcomp)
library(broom)
```


##Answering questions with data


How do we describe our data? How do we test our assumptions about the data? How do we test our hypotheses? How do we compare models? How do we make a prediction with new values?



###Our Dataset

The dataset we will use for this lesson is from the Summer Institute in Statistical Genetics at the University of Washington's course in Regression and Analysis of Variance from 2016. I like this dataset because it has a number of categorical and continuous variables, which allows us to use the same dataset for all kinds of models. Also, everyone will be familiar with the variables, which makes data interpretation easier while we are in the learning stage. 

```{r}
cholesterol <- read.delim("data/SISG-Data-cholesterol.txt", sep = " ", header = TRUE)
```



We are interested in the relationship between most of the data we have collected (age, BMI, genetic variants of rs174548 and APOE), and cholestorol. Let's start with the question: is there an association between mean serum cholestorol and age?

It is always, always, always, a good idea to plot your data and get an idea of what its distribution looks like. We can start with a simple scatterplot.

```{r}
ggplot(cholesterol, aes(age, chol)) + geom_point()
```


Let's add the mean to our plot for reference.

```{r}

ggplot(cholesterol, aes(age, chol)) + geom_point() + geom_hline(yintercept = mean(cholesterol$chol), color = "red")
```
We can plot this association and it looks like the mean might increase with age, how do we test this?


##T-tests
    
T-tests allow us to compare the means between groups. In that case, we need to split age into 2 groups to be able to compare the mean cholestorol between the groups. One way to do this is to use our `dplyr` skills to create a new column 'age_group'. We can use an if/else statement to ask the question: is age greater than 55 (the midpoint of age in our data)? If the answer is 'yes' the value is 1 and if it is 'no' (less than 55) the value is 0. We can now use a boxplot to look at the distribution of cholestorol for our 2 groups. How do we tell if these means are truely different?

```{r}
cholesterol <- cholesterol %>% mutate(age_group = ifelse(test = cholesterol$age > 55, yes = 1, no = 0))


ggplot(cholesterol, aes(factor(age_group),chol)) + geom_boxplot() +
  scale_x_discrete(labels = c("30-55", "56-80")) +
  xlab("age") +
  ylab("cholestorol (mg/dl)")
  
```


    Boxplots are a great way to visualize summary statistics for your data. As a reminder, the thick line in the center of the box is the median. The upper and lower ends of the box are the first and third quartiles (or 25th and 75th percentiles) of your data. The whiskers extend to the largest value no further than 1.5*IQR (inter-quartile range - the distance between the first and third quartiles). Data beyond these whiskers are considered outliers and plotted as individual points. This is a quick way to see how comparable your samples or variables are.



The _null hypothesis_ is always that there is no difference in the sample means between our groups. 

An _alternative hypothesis_ could be that there is a difference between the means (2-sided). Or that the difference in means is positive or negative (1-sided). 

We will use a simple student's t-test to test for the alternative hypothesis that the true difference in means is not equal to 0. (You can run a 1-sided t-test by specifiying `alternative = 'greater'` or `alternative = 'less'`.

```{r}
t.test(formula = cholesterol$chol ~ cholesterol$age_group, alternative  = "two.sided", conf.level = 0.95)
#is equivalent to
t.test(x= cholesterol$age_group, y = cholesterol$chol)
```

Our output tells us the mean for those aged 30-55 is 180 mg/dl and the mean for those aged 56-80 is 188 mg/dl and that this significant at a p-value of 0.0003125.

So we now know there is a positive relationship between cholesterol and age. However the t-test has limitations. What is the magnitude of this relationship during aging? Can we see how much cholesterol might change by in a continuous manner (ie. how much does cholesterol change per year?)? What if we don't want to break our data into groups? 


##How we Evaluate which Model to Use

Before we get too far, I have put together a table of data types and assumptions and what model should be used for each permutation. I hope to show that this means model selection is basically going through a mental checklist for your data, and that all of these models are related. 

Models have assumptions that, if violated, will be giving incorrect predictions.

###Assumptions of general linear models
1. observed values are independent of each other(independence)
1. values are normally distributed (normality)
1. constant variance, homoscedastic (equal variance)
1. observed values are related linearly to x (linearity)


For _simple linear regression_ we are modelling a continuous outcome by a single continuous variable. In our example we might be modelling cholesterol using BMI.

For _multiple linear regression_ we are modelling a continuous outcome by more than one continuous variable. This could be modelling cholestorol using BMI AND age. In this case, we must consider whether there is an _interaction_ between age and BMI on cholesterol. 

For _one-way ANOVA_ we are modelling a continuous outcome by a single categorical variable. This could be modelling cholesterol by sex. It is important that categorical variables are explicitly inputted as factors to be interpreted properly in the model. For example, since we have encoded sex as 0 and 1 (instead of 'M' and 'F'), we need to specify that sex is to be treated as a categorical variable and not a number. Therefore we turn sex into a factor of 2 levels, 0 and 1.

For _multi-way ANOVA_ we are modelling a continous outcome by more than one categorical variable. This could be modelling sex and APOE genetic variants. Again, we need to consider any interaction between our categorical variables, and we need to specify that our numeric values are encoded and to be treated as a categorical variable and not a number. APOE will be a factor of 6 levels, one for each genetic variant.

Lastly, for _ANCOVA_ we are modelling a continuous variable by a combination of categorical AND continuous variables. This could be modelling cholesterol using the genetic variants of APOE and BMI. Again, our categorical variable must be input as a factor.
...............allows for separate slopes.....................


This is a summary table you might find helpful choosing a model based on the data types you have and the asssumptions you are making.

```{r echo = FALSE}
dat <- data.frame(model = c("simple linear regression", "multiple linear regression", "one-way analysis of variance (ANOVA)", "multi-way analysis of variance (ANOVA)", "analysis of covariance (ANCOVA)", "nonlinear least squares", "nonlinear analysis of covariance (ANCOVA)", "generalized linear models"), categorical = c("X", "X", "$\\checkmark$", "$\\checkmark$ $\\checkmark$", "$\\checkmark$", "X", "$\\checkmark$", "$\\checkmark$"), continuous = c("$\\checkmark$", "$\\checkmark$ $\\checkmark$", "X", "X", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$"), linear = c("$\\checkmark$","$\\checkmark$","$\\checkmark$","$\\checkmark$", "$\\checkmark$", "X", "X", "X"), normal_errors = c("$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "$\\checkmark$", "X"), independent = rep("$\\checkmark$", 8))

kable(dat, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")

```


###Interpreting the output of our model
You don't have to know all of the assumptions are true before selecting a model. The output of our model can tell us that our assumptions are not correct. 

###Assessing the performance of the model (feedback)
+ Diagnostic plots (ie. residuals, Q-Q plots)
+ model comparisons (anova)


Take a moment to think about the question we are asking...
    What is the relationship between cholestorol and age?
    Looking at the chart we can at least say that we are dealing with continuous variables, not categorical (ie. sex or APOE). From the plot above it looks like if there is a relationship between age and cholestorol it would be linear, and points looked like they had equal-ish variance around the mean. Are values of y normally distributed? We can take a quick look by making a histogram for values of y.  

```{r}
ggplot(cholesterol, aes(x=chol)) + geom_histogram(binwidth = 10)
```
Mean serum cholesterol looks normally distributed, and values are independent. So we will be using a simple linear regression to test the association of mean serum cholesterol with age.


##Simple linear regression

What I am looking for then, is the slope of the line relating cholesterol to age, which will tell me the magnitude and direction of the relationship between these variables. We can look at the slope for linear model that `ggplot` would fit for us.

```{r}
ggplot(cholesterol, aes(age, chol)) + geom_point() + stat_smooth(method = "lm")
```

Just to make sure everyone is comfortable, we will briefly review the equation for a straight line.

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal(a + bx, {\sigma^2})
\end{equation*}


\begin{equation*}
y = a + bx + \epsilon, \epsilon \verb|~| N\{0, \sigma^2\}
\end{equation*}


y is our dependent variable that we are attempting to model and x is our independent variable. Here a is the intercept, which is the value of x where y = 0 (where x crosses the y-axis), and b is the slope of the line, which is the change in y corresponding to a unit increase in x. A flat line would mean that there is no association between x and y. The above example has a positive association with a positive slope, meaning that y increases as values of x increase. With a negative association and negative slope, y decreases as values of x decrease. The interpretation in our example is that the slope is the difference in mean serum cholesterol associated with a one year increase in age.

With a straight line we are not, of course, plotting through all of our points, but rather the mean of an outcome in y as a function of x. For example, there are values of cholestorol for about six 50 year-olds, and our line will fall somewhere close to the mean of these values. Likewise, there is a distribution for values of y at a given x, and the assumption is that this distribution is normally distributed.

![SISG_2016_2](img/y_dist.png)

In this equation we also have some normally distributed variance - sampling error exists in our estimates, because different estimates give different means. 


Okay, but how do we actually find the best fitting line? We are using _least squares estimation_; we are minimizing the sum of squares of the vertical distances from the observed points to the least squares regression line.

![](img/least_squares.png)
 
 
 
Let's actually run this simple linear regression.

When we use code for this in R, the intercept and slope terms are implicit.

_R code:_ 
\begin{equation*}
lm(y \verb|~| x)
\end{equation*}

To force the intercept to zero: Y~ Normal(bx, sigma^2)

_R code:_ 
\begin{equation*}
lm(y \verb|~| x-1)
\end{equation*}

Our dependent variable (cholesterol) is a function (~) of our independent variable (age), which is entered as a formula, along with the dataset. 
```{r}
lm(chol~age, data = cholesterol)
```

The model will output our formula, and our slope and intercept. However, if we save the model into an object, 'fit', we get a list object of the model, its input, and all associated statistics. We can look at a summary and get our residuals, errors, p-values and more in addition to our coefficients.

```{r}
fit <- lm(chol~age, data = cholesterol)

summary(fit)
```


__Interpretation__ 

Let's look for the intercept and slope here. The Intercept is 166.9 and the slope is 0.31. What does that actually mean? It means a baby (age 0) would be expected to have 167 mg/dl average serum cholesterol. For every yearly increase in age, mean serum cholesterol is expected to increase by 0.31 mg/dl. These results are significant with a p-value < 0.001. We can say that the mean serum cholesterol is significantly higher in older individuals.

_Confidence intervals_ will cover the true parameter x% of the time.

```{r}
confint(fit)
```

We are 95% confident that the difference in mean cholesterol associated with a one year increase in age is between 0.16 and 0.46 mg/dl.


Predicting values assumes that your model is true. This might be fair within the range of your data. This is to be interpreted with caution outside the range of your data.

![](img/extrapolate.png)
</br>

![xkcd](img/extrapolating.png)

If you want to predict the mean at a particular point, for example, at age 47. 
```{r}
predict.lm(fit, newdata = data.frame(age=47), interval = "confidence")
```


If you want to predict where a new observation at age 47 might be.

```{r}
predict.lm(fit, newdata = data.frame(age=47), interval = "prediction")
```

Notice the difference in the upper and lower boundaries in these predictions. The first is the prediction for the mean serum cholestorol for individuals age 47 and the second is for a single new individual of age 47. The second prediction has to account for random variability around the mean, rather than just the precision of the estimate of the mean.


R^2 - correlation coefficient squared - ours (multiple R-squared) is 0.04. What does this tell us? 4% of the variability in cholestorol is explained by age.

Degrees of Freedom
Decomposition of sum of squares
mean squares = SS/df
F-Statistic = MSR/MSE

in simple linear regression F-stat = (t-stat for slope)^2 for the hypothesis that the slope is not zero (ie. 2-sided)




##Multiple linear regression

Multiple continuous variables are included to predict the outcome. Our question can now be: is there a statistically significant relationship between mean serum cholestorl and BMI after adjusting for other predictors (ie. age) in the model?

***

###Adding covariates that are powers of a variable (polynomial regression)

When we talk about 'linear' what we are interested in is the linear function of the _parameters_ and not the independent variables. In the example below, the parameters a, b1, and b2 are linear even though we have the independent variable has a quadratic component, x^2. 

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal(a + b_1x + b_2x^2, {\sigma^2})
\end{equation*}

If we were to write this in R, again our intercept and coefficients are implicit. To write the quadratic term we us the function `I` which just means 'asis'. 

_R code:_ 

lm(y ~ x + I(x^2))

The following equation is non-linear with respect to the parameter b, and is not a model for linear regression.

\begin{equation*}
Y \verb|~|  Normal(ax^b, {\sigma^2}) 
\end{equation*}

***

###Adding extra variables to our model

How we are interested in multiple linear regression is to improve our model by adding extra variable we think might have an effect on our outcome values. In the example below, we are adding the independent variables x1, x2, x3, and each of these terms has their own linear parameter b1, b2, b3.

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal(a + b_1x + b_2x_2 + b_3x_3, {\sigma^2})
\end{equation*}


b2 is the expected mean change in unit per change in x2 if x1 is held constant (controlling for x1). The null hypothesis is that all b1, b2, b3 =0. The alternative hypothesis is that at least one of these parameters is not null. 

Again intercept and coefficients are implicit in the the `lm` function.

_R code:_ 

lm(y ~ x_1 +x_2 + x_3)

We know that age has an effect on cholesterol. With our new model we want to test whether BMI has an association with cholestorol when controlling for age. Let's look graphically at these relationships to help us understand our model. First let's plot BMI vs cholestorol. We can add a linear fit to make sure we are expecting a positive slope.

```{r}
ggplot(cholesterol, aes(BMI, chol)) + geom_point() + stat_smooth(method = "lm")

```

We should also take a look at the relationship between BMI and age.

```{r}
ggplot(cholesterol, aes(age, BMI)) + geom_point() + stat_smooth(method = "lm")

```

Cholesterol increases with BMI. BMI increases with age. We will look at the association of age while holding BMI constant just so our model output is in the same order as previously. Switching the variables here will not change our slope or intercept.

```{r}
mfit <- lm(chol ~ age + BMI, data = cholesterol)

summary(mfit)
```

__Interpretation__

So our equation would now look like y = 137 + 0.2age + 1.43BMI. Interpreting the 0.2 slope would be the estimated increase in mean serum cholestorol over after one year holding BMI constant (for 2 subjects with the same BMI). This is less than our previous value of 0.31. Why do the estimates differ?

Before, we were not controlling for BMI. Our estimates of the age association for the mean increase in cholestorol is now for subjects with the same BMI and not for subjects with all BMIs.

Here it looks like both age and BMI are significant. But we might want to verify - did adding BMI actually make our model better?

We can compare these models with the `anova` function. With _2 lm objects_, this function _tests the models_ against one another and prints these results in an analysis of variance table. (Given _1 lm object_, it will test whether model _terms_ are significant - we will be using the function in this format later.)

```{r}
anova(fit, mfit)
```

Our second model is a signifcant improvement.




###Interaction terms 

What is meant by an _interaction_? The slope with respect to one covariate changes linearly as a function of another covariate. 
The association between the response and the predictor changes across the range of the new variable. This is different than a _confounding factor_, which is associated with the predictor and response, however the association between the response and predictor is constant across the range of the new variable.


The difference in means changes additionally by b3 for each unit difference in x2. b3 is the difference of differences. The slope of x1 changes with x2, because b3 is changing.


_Expression:_ 

\begin{equation*}
Y  \verb|~|  Normal(a + b_1x_1 + b_2x_2 + b_3x_1x_2, {\sigma^2})   
\end{equation*}

When testing for an interaction between 2 input variables, the `lm` input uses an asterik '*' instead of a plus sign.

_R code:_ 

\begin{equation*}
lm(y \verb|~| x_1*x_2)
\end{equation*}


***
__Challenge__ 


<div style="float:left;margin:0 10px 10px 0" markdown="1">
![](img/04722ac51b800387ee8498fb072834e7.jpg){width=150px}

</div>

Test if there is an interaction between age and BMI in a model predicting cholesterol. Is the interaction significant? Is there a difference between this model and the model with age as the only variable? What about the BMI and age model without interaction?


</br>
</br>
</br>

***


```{r include = FALSE}
ifit <- lm(chol ~ age * BMI, data = cholesterol)

summary(ifit)

anova(fit, ifit)
anova(mfit, ifit)
```


##One-way analysis of variance (ANOVA)

In the analysis of variance (ANOVA) independent variables are categorical (factors) rather than continuous.

Does the genetic factor rs174548 have an effect on cholesterol levels?

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal({\alpha_i}, {\sigma^2}) 
\end{equation*}

We still use the `lm` function, however we replace our continuous variable with f, a categorical variable (factor). If your data is character type, R will automatically make factors for you. However if your data is numeric, R will interpret it as continuous. In this case, you need to make your numeric data a factor first using `factor`.

_R code:_ 


$\begin{aligned}
\text{lm(y }\verb|~| \text{f)}
\end{aligned}$


R parameterizes the model in terms of the differences between the first group and subsequent groups rather than in terms of the mean of each group. This is similar to the interpretation of the previous linear models. (You can tell it to fit the means of each group using: lm(y ~ f-1)).



We can first plot the relationship between rs174548 and cholestorol. 

```{r}
ggplot(cholesterol, aes(as.factor(rs174548), chol)) + geom_boxplot()

```
Our genetic factor has 3 groups, and we will be comparing the means for each of these groups. These groups have high variance, and there is a good deal of overlap between them.

To assess wherther the means are equal, the model compares:

- variation between the sample means (MSR)
- natural variation of the observations within the sample (MSE)

The larger the MSR compared to the MSE the more support there is for a difference between the population means.
The ratio of MSR/MSE is the F-statistic.

###Dummy Variables

We can encode our categorical variable as a _dummy variable_. 0 really means C/C, 1 is C/G and 2 is G/G. But instead we can create k-1 separate columns of 0's and 1's. The omitted category is the reference group. Otherwise 0 means it is not that SNP and 1 means it is that SNP. Each genetic factor has a unique encoding.

```{r echo = FALSE}
dat3 <- data.frame(rs174548 = c("C/C", "C/G", "G/G"), x_1=c(0,1,0), x_2 = c(0,0,1))

kable(dat3, "html") %>%
  kable_styling(full_width = FALSE, position = "center")
```

__Interpretation__

This makes the interpretation of the model a bit trickier.     

- beta0 - mean cholesterol when rs174548 is C/C
- beta0 +beta1 - mean cholestor when rs174548 is C/G
- beta0 + beta2 - mean cholestorol when rs174548 is G/G

Alternatively

- b1 is the differnce in mean cholestorl levels between groups with rs174548 equal to C/G and C/C
- b2 is the difference in mean cholesterol levels between groups with rs174548 equal to G/G and C/C

So you can really just think of each of these groups having their own means. ie.u2 = beta0 + beta1. We are testing the hypothesis whether these means are equal or not.

R will create dummy variables in the background if you state you have a categorical variable.

```{r}
anfit1 <- lm(chol ~ as.factor(rs174548), data = cholesterol)

summary(anfit1)
```

```{r}
anova(anfit1)
```
This tells us that there is a difference in means ie. rejects the null hypothesis that all means are the same, but doesn't tell us which means are different.

In order to look at this we need to look at multiple comparisons.  
u0 = u1, u0=u2, u1 = u2 (pairwise)

###Multiple test correction

Multiple comparisons at the 5% levels makes the family-wise error rate - the probability of making a false rejection, increases. This is where corrections can come in such as the Bonferroni (alpha/k or multiply pvalues by k). Simple and conservative.


```{r}
tfit <- lm(chol ~ -1 + as.factor(rs174548), data = cholesterol)

#generate a contrast matrix for multiple comparisons
M = contrMat(table(cholesterol$rs174548), type = "Tukey")
M
#get estimates for multiple comparisons, 'general linear hypothesis testing'
mc = glht(tfit, linfct = M)

#adjust pvalues for mulitple comparisons
summary(mc, test = adjusted("none"))
summary(mc, test = adjusted("bonferroni"))

#other types
summary(mc, test = adjusted("BH"))
summary(mc, test = adjusted("fdr"))
```
It is possible we would want to do a nonpairwise comparison (test the mean for C/C against the grouped genotypes C/G and G/G.
... this may be beyond the scope of this lesson.




##Multi-way analysis of variance (ANOVA)

Two or more discrete/categorical variables (factors) are used to model our outcome.

Does the effect of the genetic factor rs174548 differ between males and females?
We need to test whether there is an effect of our factors and also if there is an interaction between them.

alpha, beta and gamma are our categorical variables. i is the level of the first group, and j is the level of the second group.

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal({\alpha_i} + {\beta_j} + {\gamma_{ij}}, {\sigma^2}) 
\end{equation*}

Our R code models our two categorical variables as factors.

_R code:_ 

lm(y~ f~1~ + f~2~), testing for main effects without interaction
lm(y~ f~1~*f~2~), testing for the main effects with interaction


The following diagram will help us visualize the differences in coefficients with and without interaction between 2 categorical variables.


In this first scenario, the difference in the means between groups defined by factor B does not depend on the level of factor A and vice versa. This means that there is no interaction, and the lines between the factor groups are parallel. In the second scenario the difference in the means between groups defined by factor B changes when A2 is present. There is an interaction and the lines are not parallel.
![SISG_2016](img/2wayanova.png)

We can first run a two-way model without testing the interaction.

```{r}
twofit <-lm(chol ~ as.factor(sex) + as.factor(rs174548), data = cholesterol) 

summary(twofit)
```
__Interpretation__

- estimated mean cholesterol for males in C/C group is the intercept (175.36)
- estimated diff in mean cholesterol between females and males controlled for genotype (11.05)
- estimated diff in mean betweeen C/G and C/C groups controlled for gender (7.24)
- estimated diff in mean betweeen G/G and C/C groups controlled for gender (5.18)

There is evidence cholestorol is associated with gender (p<0.001).


How does this compare to the model with just gender?

```{r}
genfit <- lm(chol ~ as.factor(sex), data = cholesterol)
```

Worth it!
```{r}
anova(genfit, twofit)
```
There is evidence cholesterol is associated with genotype(p=0.005).


We can now check the two-way anova with the interaction.

```{r}
intfit2 <- lm(chol ~ as.factor(sex) * as.factor(rs174548), data = cholesterol)

summary(intfit2)
```
__Interpretation__

- the estimated mean cholesterol for males in the C/C group is 178.
- the estimated mean cholesterol for females in the C/C group is 178 + 5.7. 
- the estimated mean cholesterol for men in the C/G group 178 + 0.95.
- the estimated mean cholesterol for females in the C/G group is 178 + 5.7 + 0.95 + 12.7.


Let's compare the without interaction and with interaction model.

```{r}
anova(twofit,intfit2)
```

There is evidence for an interaction between genotype and sex (p = 0.015).


##Analysis of covariance (ANCOVA)

The analysis of covariance (ANCOVA) model allows for different intercepts and slopes with repect to a continuous variable in different categorical groups. ANCOVA, therefore, has a linear regression component.

Now we can ask if there the relationship between age and cholesterol is affected by gender?

_Expression:_ 

\begin{equation*}
Y \verb|~| Normal({\alpha_i} + {\beta_{ix}}, {\sigma^2}) 
\end{equation*}


R code:     

lm(y~f + x), for parallel slopes (no interaction)     
lm(y~f*x), for non-parallel slopes (interaction)     
lm(y~f) for zero slopes but different intercepts     
lm(y~x) a single slope     

Parameters are the intercept of the first factor level, the slope with respect to x for the first factor level, the differences in the intercepts for each factor level other than the first, and the differences in slopes for each factor level other than the first.

Now we are going to throw in a categorical variable and ask if the relationship between age and cholestorol is affected by gender.

```{r}
mfit2 <- lm(chol ~ age + sex, data = cholesterol)

summary(mfit2)
```

__Interpretation__

Okay, so our model would look like 162 + 0.3age + 10.5sex. Controlling for sex, mean average cholestorol increases by 0.3 for an additional year of age. This is close to the slope for our model of just cholesterol, 0.31. This does not necessarily mean that the age/cholesterol relationship is the same in males and females. We need to look at the interaction term.


```{r}
intfit <- lm(chol ~ age * sex, data = cholesterol)

summary(intfit)
```

__Interpretation__ 

Males are coded as 0 and females are coded as 1 in this model. The intercept term is the mean serum cholestorol for MALES at age 0. The slope term for age is the difference in mean cholestorl associated with one year change in age for MALES. The slope for sex is the difference in mean cholestorol between males and females at age 0. The interaction term is the difference in the change in mean cholesterol associated with each one year change in age for females compared to males. Sex exerts a mall and not statistically significant effect on the age/cholestorol relationship.

Let's check this with anova (an F-test).

```{r}
anova(mfit2, intfit)
```
Adding the interaction term did not improve the model significantly.

```{r}
anova(fit, mfit2)
```

```{r}
ggplot(cholesterol, aes(age, chol, color = factor(sex))) + geom_point() + stat_smooth(method = "lm")
```
__Interpretation__

So gender doesn't change the relationship between age and cholesterol, these lines are almost parallel (another way to put it is whether you are male or female you cholestorl will on average be increasing by 0.3 mg/dl a year), but there is a different mean serum cholestorol estimate for males vs females that differs by 14.6 dg/ml.


***
__Challenge__ 


<div style="float:left;margin:0 10px 10px 0" markdown="1">
![](img/04722ac51b800387ee8498fb072834e7.jpg){width=150px}

</div>

Does the effect of the genetic factor rs174548 differ depending on a subject's age? Make a plot of age versus cholesterol and color points by the genetic factor rs174548. Add a linear model to the plot. Are you expecting an interaction based on this plot? Test models for the association between cholesterol and age controlling for the genetic factor rs174548 with interaction and without interaction. Look at the summary statistics for each model fit. How would you interpret the results? Compare the two models with an analysis of variance table.    

</br>
</br>
</br>

***



```{r include = FALSE}
#challenge question plot
ggplot(cholesterol, aes(age, chol, color = as.factor(rs174548))) + geom_point() + stat_smooth(method = "lm")

#model without interaction
ancfit <- lm(chol ~ as.factor(rs174548) + age, data = cholesterol)
summary(ancfit)

#model with interaction
intfit3 <- lm(chol ~ as.factor(rs174548) * age, data = cholesterol)
summary(intfit3)

#compare models
anova(ancfit, intfit3)
```


##Review: Models we used today

Before we move on I want to take a step back and quickly review the models and code we've gone through today. Firstly, with our example dataset, and then more generally. I hope you can see that though conceptually different, getting a handle on the code isn't too bad.  

For all of these models we are trying to determine the effect of different variables on cholesterol. The differences are whether we are using continuous data, categorical data, a mixture of data types, and whether there is an interaction between our input variables.

We have started with models assuming normally distributed errors, and we will investigate models with non-normal errors in the next lesson.  



```{r echo = FALSE}
dat2 <- data.frame(model = c("simple linear regression", "multiple linear regression", "one-way analysis of variance (ANOVA)", "multi-way analysis of variance (ANOVA)", "analysis of covariance (ANCOVA)"), categorical = c("X", "X", "$\\checkmark$", "$\\checkmark$ $\\checkmark$", "$\\checkmark$"), continuous = c("$\\checkmark$", "$\\checkmark$ $\\checkmark$", "X", "X", "$\\checkmark$"),R_code = c("lm(chol ~ BMI)", "lm(chol ~ BMI + age)", "lm(chol ~ factor(sex))", "lm(chol ~ factor(sex)*factor(APOE))", "lm(chol~factor(APOE)*BMI) "))


kable(dat2, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")

```

In the table below, our R code for each of the models has been generalized. Here, y is our predictor variable, x is a continuous variable, and f is a categorical variable (factor). * denotes an interaction.

```{r echo = FALSE}
dat2 <- data.frame(model = c("simple linear regression", "multiple linear regression", "one-way analysis of variance (ANOVA)", "multi-way analysis of variance (ANOVA)", "analysis of covariance (ANCOVA)"), R_code = c("lm(y ~ x)", "lm(y ~ x + I(x^2))", "lm(y ~ f)", "lm(y ~ f~1~*f~2~)", "lm(y~f*x)"))


kable(dat2, "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")

```

You need not memorize any of these charts - you may just want to use them to orient yourself in the future. Much of the R code seems the same whether you are doing multiple linear regression, ANOVA or ANCOVA, so it is good to have a reference point.


##Model checking

Bartlett's test - test whether or not population variances are all the same
```{r}
bartlett.test(chol ~ as.factor(rs174548), data = cholesterol)
```
This is telling us that the variance is not statistically different between our populations. Our assumption of equal variance is  validated.

However, you can use the one-way anova test that allows for unequal variances.

```{r}
oneway.test(chol ~ as.factor(rs174548), data = cholesterol)
```
Or you can do one-way anova with robust standard errors.
```{r}
summary(gee(chol ~ as.factor(rs174548), data = cholesterol, id=seq(1, length(chol))))
```

 - Kruskal-wallis tst = wilcox test with corrections?




##Checking Residuals

_Residuals_ - the difference between the observed response and the predicted response, can be used to identify poorly fit data points, unequal variance (heteroscedasticity), nonlinear relationships, identify additional variables, and examine the normality assumption.

Look at the residuals vs x, residuals vs y, residual histogram or qqplot - are there any patterns? The residuals are taken from fit, which also contains the inputs of our model.


```{r}
str(fit)
```
For example, plotting residuals against x (age), should be unstructured and centered at 0.

```{r}
ggplot(cholesterol, aes(x=age, y=fit$residuals)) + geom_point() + geom_hline(yintercept=0, color="black")

```

If the residuals look like they are grouped in one section of the plot, or follow a pattern (ie. looks quadratic - you would have a nonlinear association), then the model is not a good fit. If it looks like a sideways tornado, then errors are increasing with x, and this is non-constant variance.

##Check the (Non-) Normality of Errors


The structure of the `lm` output is a list of 12, which is possible, though annoying to grab data from. Use the `broom()` package to get info out of linear models in a glorious dataframe format that we know and love. 

```{r}
datfit <- augment(fit)
```




```{r}
ggplot(datfit, aes(.fitted, .resid)) + geom_point()  + geom_hline(yintercept=0, color="black")

```

##qqplots

Does our data follow the (normal) distribution? The data is plotted against a theoretical distribution. Points should fall on the straight line. Anything not fitting are moving away from the distribution. 

```{r}
qqnorm(fit$residuals)
```

This looks pretty straight. We have normality of errors.

Let's try a less perfect example and look at the relationship between age and triglycerides.

```{r}
ggplot(cholesterol, aes(age, TG)) + geom_point() + stat_smooth(method = "lm")
```



```{r}
fitTG <- lm(TG ~ age, data = cholesterol)

datfitTG <- augment(fitTG)
```




```{r}
ggplot(datfitTG, aes(.fitted, .resid)) + geom_point()  + geom_hline(yintercept=0, color="black")

```

Our residuals are now increasing with increasing values of y. 

```{r}
qqnorm(datfitTG$.resid)
```

Our qqplot points are deviating from the line suggesting a poor fit for our model.

We have a case of non-constant variance (heteroscedasticity). This means that there is a mean-variance relationship. We now need some different tools.

To account for this we can use:

1. Robust standard errors
1. Data transformation
1. Use a different model that does not assume constant variance (glm)

_Robust standard errors_ correctly estimate variability of parameter estimates even under non-constant variance. This does not affect point estimates, but corrects confidence intervals and p-values.

To do this, we use a package called 'gee'.

```{r}
geefit <- gee(TG ~ age, data = cholesterol, id = seq(1, length(age)))

summary(geefit)
```

We have the same point estimates, but our error estimates have now changed.
(Note: residuals in geefit are the originals)


_Data transformation_ can solve some nonlinearity, unequal variance and non-normality problems when applied to the dependent variable, the independent variable, or both. However, interpreting the results of these transformations can be tricky.


```{r}
logfit <- lm(log(TG) ~ age, data = cholesterol)

logdat <- augment(logfit)
summary(logfit)
```

```{r}
ggplot(logdat, aes(.fitted, .resid)) + geom_point()  + geom_hline(yintercept=0, color="black")
```

We corrected the non-constant variance issue, but it is harder to interpret our model. 

This equation does not take into account any __interaction__ BMI might have with age on cholesterol levels. To denote the interaction term we use `*`. For example, lm(chol~ BMI + age + BMI\*age) or for the term alone lm(chol~BMI*age).

....Slide 97 from SISG_5_2 is impact of violations to model assumptions - think about whether something like this should be included.


utput: summary - range and quartile of the residuals, standard errors, p-values for coefficients, R^2 and F stats for the full model, 
coef - coefficients alson, coef(summary()) table of estimates, standard errors, t-statistics and pvalues, confint confidencce intervals, plot - diagnostics on assumptions of  model fit, anova anova table 





What happens if we don't have linearity?
nonlinear least squares

1. nonlinear
2. independece
3. normal errors

Examples: power law \begin{equation*} 
Y \verb|~| Normal(ax^b, {\sigma^2}) \end{equation*} is non-linear wrt b,

Ricker model \begin{equation*}  
Y \verb|~| Normal(axe^{-rx}, {\sigma^2}) \end{equation*} 

-minimize the sum of least squares (equivalent to minimizing the negative log likehoold)

nls(y~a*x^b, start = list(a=1, b=1))

-nonlinear analogue  of ANCOVA - nonlinear covariates and categorical variables
#not sure if I have interpreted this rights
nlsList(y ~ a*x^b|x~2~, data, start = list(a=1, b=1))
-fits separate a and b paramters for the two different groups

#Prediction



__Challenge:__      

Given this dataset, answer this question. Is this the best model for the job? What else could you apply? Can you prove this is any better?

__Resources:__      

<https://github.com/ttimbers/lm_and_glm/blob/master/lm_and_glm.Rmd>          
<https://github.com/seananderson/glmm-course>          
<http://michael.hahsler.net/SMU/EMIS7331/R/regression.html>     
<https://ms.mcmaster.ca/~bolker/emdbook/book.pdf>
<http://www.differencebetween.net/science/mathematics-statistics/difference-between-ancova-and-regression/>
    


##Post-Lesson Assessment
***
_Questions_

- Speed: Too slow, too fast, just right
- Content: Too easy, too hard, just right
- From the description of the lesson, the content was what I expected to learn. T/F
- What was the most useful thing you learned?
- What was the least useful thing?
- Comments/suggestions for improvement.


##Notes
***
- Possibly split lesson 5 - definately - does that put lesson 6 as glms + functions or do we need another lesson?
- Do we want to include nonlinear models, parametric vs nonparametric in this lesson? It might be better to go slow with this so people don't get confused. 